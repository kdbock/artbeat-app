  test('getSubscriptionById should return subscription if it exists', () async {
    // Arrange - Create a test subscription
    final subscriptionRef = fakeFirestore.collection('subscriptions').doc('test-subscription-id');
    await subscriptionRef.set({
      'id': 'test-subscription-id',
      'userId': testUserId,
      'tier': 'artistPro',
      'startDate': Timestamp.fromDate(DateTime.now().subtract(Duration(days: 10))),
      'endDate': Timestamp.fromDate(DateTime.now().add(Duration(days: 20))),
      'stripeSubscriptionId': 'stripe-sub-123',
      'stripePriceId': 'price-artistPro-monthly',
      'stripeCustomerId': 'cus-123',
      'autoRenew': true,
      'createdAt': FieldValue.serverTimestamp(),
      'updatedAt': FieldValue.serverTimestamp(),
    });

    // Act
    final subscription = await subscriptionService.getSubscriptionById('test-subscription-id');

    // Assert
    expect(subscription, isNotNull);
    expect(subscription!.id, 'test-subscription-id');
    expect(subscription.userId, testUserId);
    expect(subscription.tier, SubscriptionTier.pro);
  });

  test('getSubscriptionById should return null if subscription does not exist', () async {
    // Act
    final subscription = await subscriptionService.getSubscriptionById('non-existent-subscription');

    // Assert
    expect(subscription, isNull);
  });

  test('createSubscription should handle Stripe API errors gracefully', () async {
    // Arrange - Override mock to throw an exception
    final mockFailingStripeApiService = MockStripeApiService();
    when(mockFailingStripeApiService.createSubscription(any, any))
        .thenThrow(Exception('Stripe API Error'));

    final failingSubscriptionService = TestableSubscriptionService(
      firestore: fakeFirestore,
      auth: mockAuth,
      stripeApiService: mockFailingStripeApiService,
    );

    // Act & Assert
    expect(
      () => failingSubscriptionService.createSubscription(
        userId: testUserId,
        tier: SubscriptionTier.pro,
        stripePriceId: 'price-artistPro-monthly',
        stripeCustomerId: 'cus-123',
        autoRenew: true,
        startDate: DateTime.now(),
        endDate: DateTime.now().add(Duration(days: 30)),
      ),
      throwsA(isA<Exception>()),
    );
  });

  test('cancelSubscription should throw exception if not authenticated', () async {
    // Arrange
    when(mockAuth.currentUser).thenReturn(null);

    // Act & Assert
    expect(
      () => subscriptionService.cancelSubscription('any-subscription-id'),
      throwsA(isA<Exception>()),
    );
  });

  test('cancelSubscription should throw exception if subscription does not exist', () async {
    // Act & Assert
    expect(
      () => subscriptionService.cancelSubscription('non-existent-subscription'),
      throwsA(isA<Exception>()),
    );
  });

  test('cancelSubscription should throw exception if user does not own subscription', () async {
    // Arrange - Create a subscription owned by someone else
    final subscriptionRef = fakeFirestore.collection('subscriptions').doc('other-user-subscription');
    await subscriptionRef.set({
      'id': 'other-user-subscription',
      'userId': 'other-user-id', // Different user ID
      'tier': 'artistPro',
      'startDate': Timestamp.fromDate(DateTime.now().subtract(Duration(days: 10))),
      'endDate': Timestamp.fromDate(DateTime.now().add(Duration(days: 20))),
      'stripeSubscriptionId': 'stripe-sub-456',
      'autoRenew': true,
      'createdAt': FieldValue.serverTimestamp(),
      'updatedAt': FieldValue.serverTimestamp(),
    });

    // Act & Assert
    expect(
      () => subscriptionService.cancelSubscription('other-user-subscription'),
      throwsA(isA<Exception>()),
    );
  });

  test('upgradeSubscription should throw exception if not authenticated', () async {
    // Arrange
    when(mockAuth.currentUser).thenReturn(null);

    // Act & Assert
    expect(
      () => subscriptionService.upgradeSubscription(
        subscriptionId: 'any-subscription-id',
        newTier: SubscriptionTier.gallery,
        newStripePriceId: 'price-gallery-monthly',
      ),
      throwsA(isA<Exception>()),
    );
  });

  test('upgradeSubscription should throw exception if subscription does not exist', () async {
    // Act & Assert
    expect(
      () => subscriptionService.upgradeSubscription(
        subscriptionId: 'non-existent-subscription',
        newTier: SubscriptionTier.gallery,
        newStripePriceId: 'price-gallery-monthly',
      ),
      throwsA(isA<Exception>()),
    );
  });

  test('upgradeSubscription should throw exception if user does not own subscription', () async {
    // Arrange - Create a subscription owned by someone else
    final subscriptionRef = fakeFirestore.collection('subscriptions').doc('other-user-subscription');
    await subscriptionRef.set({
      'id': 'other-user-subscription',
      'userId': 'other-user-id', // Different user ID
      'tier': 'artistPro',
      'startDate': Timestamp.fromDate(DateTime.now().subtract(Duration(days: 10))),
      'endDate': Timestamp.fromDate(DateTime.now().add(Duration(days: 20))),
      'stripeSubscriptionId': 'stripe-sub-456',
      'autoRenew': true,
      'createdAt': FieldValue.serverTimestamp(),
      'updatedAt': FieldValue.serverTimestamp(),
    });

    // Act & Assert
    expect(
      () => subscriptionService.upgradeSubscription(
        subscriptionId: 'other-user-subscription',
        newTier: SubscriptionTier.gallery,
        newStripePriceId: 'price-gallery-monthly',
      ),
      throwsA(isA<Exception>()),
    );
  });

  test('isActive property works correctly on subscription model', () async {
    // Arrange - Create an active subscription
    final activeSubscription = SubscriptionModel(
      id: 'active-sub',
      userId: testUserId,
      tier: SubscriptionTier.pro,
      startDate: DateTime.now().subtract(Duration(days: 10)),
      endDate: DateTime.now().add(Duration(days: 20)),
      stripeSubscriptionId: 'stripe-sub-123',
      autoRenew: true,
      createdAt: DateTime.now().subtract(Duration(days: 10)),
      updatedAt: DateTime.now().subtract(Duration(days: 10)),
    );
    
    // Create an inactive subscription (past end date)
    final inactiveSubscription = SubscriptionModel(
      id: 'inactive-sub',
      userId: testUserId,
      tier: SubscriptionTier.pro,
      startDate: DateTime.now().subtract(Duration(days: 60)),
      endDate: DateTime.now().subtract(Duration(days: 30)),
      stripeSubscriptionId: 'stripe-sub-456',
      autoRenew: false,
      createdAt: DateTime.now().subtract(Duration(days: 60)),
      updatedAt: DateTime.now().subtract(Duration(days: 30)),
    );
    
    // Create a canceled subscription in grace period
    final canceledSubscription = SubscriptionModel(
      id: 'canceled-sub',
      userId: testUserId,
      tier: SubscriptionTier.pro,
      startDate: DateTime.now().subtract(Duration(days: 20)),
      endDate: DateTime.now().add(Duration(days: 10)),
      stripeSubscriptionId: 'stripe-sub-789',
      autoRenew: false,
      canceledAt: DateTime.now().subtract(Duration(days: 5)),
      createdAt: DateTime.now().subtract(Duration(days: 20)),
      updatedAt: DateTime.now().subtract(Duration(days: 5)),
    );

    // Assert
    expect(activeSubscription.isActive, isTrue);
    expect(inactiveSubscription.isActive, isFalse);
    expect(canceledSubscription.isActive, isFalse);
    expect(canceledSubscription.isGracePeriod, isTrue);
    
    expect(activeSubscription.status, 'active');
    expect(inactiveSubscription.status, 'inactive');
    
    expect(activeSubscription.daysRemaining, greaterThan(0));
    expect(inactiveSubscription.daysRemaining, 0);
  });
